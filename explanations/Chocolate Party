Here's a `README.md`-style explanation for your **"Chocolate Party"** problem, suitable for uploading alongside your code:

---

# ğŸ« Chocolate Party â€“ Problem Explanation

## âœ… Problem Statement

Abhi has `N` chocolate bags, each containing `arr[i]` chocolates. He wants to distribute all of them equally among `K` friends, **without making anyone angry**. Each friend must get **the same total number of chocolates**, and **all bags must be used**.

Your task is to determine whether such a distribution is possible for multiple test cases.

---

## ğŸ§¾ Input Format

* First line: Integer `T` â€“ number of test cases
* For each test case:

  * Line 1: Two integers `N` and `K` â€“ number of chocolate bags and number of friends
  * Line 2: `N` integers â€“ the array `arr[]`, where `arr[i]` is the number of chocolates in the `i-th` bag

---

## ğŸ–¨ï¸ Output Format

* For each test case, print `"Yes"` if it's possible to distribute chocolates equally among all `K` friends, otherwise print `"No"`.

---

## ğŸ“Œ Constraints

* `1 â‰¤ T â‰¤ 10^4`
* `1 â‰¤ K â‰¤ N â‰¤ 20`
* `0 â‰¤ arr[i] â‰¤ 10^3`

---

## ğŸ’¡ Approach

### Key Observations:

1. **Total Chocolates:** If the sum of all chocolates `sum` is not divisible by `K`, it's **impossible** to divide them equally â†’ output `"No"`.

2. **Subset Partitioning:** We need to partition the chocolate bags into `K` groups where **each group sums to `target = sum / K`**.

3. **Backtracking (DFS):** This is a classic **K-partition problem**, solvable with DFS + backtracking due to small size constraints (`N â‰¤ 20`).

4. The DFS works by finding a path then starting all over again from index 0, while it rejects the elements who have been visited finding next starting element,
     if multiple path are present it selects the path which give total path sum as k.

---

## ğŸ” Algorithm (DFS + Backtracking)

### Step-by-Step:

1. Calculate total sum of chocolates.
2. If `sum % K != 0` â†’ return `"No"` (early exit).
3. Use recursive DFS to try to form `K` subsets of chocolates that each sum to `target`.
4. Use a `visited[]` array to mark chocolate bags that are already assigned to a subset.
5. For each subset:

   * Try to build a subset starting from index 0
   * Skip used or oversized values
   * Backtrack if dead-end

---

## ğŸ§  Time Complexity

* Worst-case exponential due to backtracking: `O(K * 2^N)`
* Efficient in practice because `N` is small (`â‰¤ 20`) and pruning with backtracking helps.

---

## âœ… Sample Input

```
2
4 2
1 2 3 4
3 3
2 2 2
```

## âœ… Sample Output

```
Yes
Yes
```

---

## ğŸ§¾ Explanation of Code

```cpp
bool dfs(...): // Recursive function to form groups
    Base Case:
        if (k == 0): return true // all groups formed
        if (sum == target): return dfs(..., k-1, 0, 0) // group formed, go to next
    Recursive:
        Loop over remaining chocolates
            If not used and within target:
                mark used
                dfs with updated sum
                backtrack

bool canPartition(...): // Calls dfs with initial parameters

main():
    For each test case:
        Read N, K
        Compute sum
        If not divisible â†’ No
        Else â†’ call canPartition to check possibility
```

---

## ğŸ¯ Conclusion

This problem is a real-world variation of the **"Partition to K Equal Sum Subsets"** and is ideal for practicing:

* DFS + backtracking
* Subset-sum partitioning
* Pruning and base case design

---
